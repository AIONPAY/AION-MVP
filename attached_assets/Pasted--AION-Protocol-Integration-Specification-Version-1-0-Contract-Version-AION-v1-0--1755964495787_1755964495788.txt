# üîß AION Protocol Integration Specification

**Version**: 1.0  
**Contract Version**: AION v1.0  
**Last Updated**: 2024

This document defines the **exact** interface for integrating with the AION Protocol smart contract. Use this as your definitive reference for all interactions.

> **üî• NEW: EIP-712 Signatures** - AION now uses structured data signatures that show users **exactly what they're signing** in MetaMask instead of cryptic hex strings. This dramatically improves user experience and security. [See full UX details ‚Üí](#user-experience-with-eip-712-signatures)

## üìë Table of Contents

1. [üìã Contract Information](#contract-information)
2. [‚ö° EIP-712 Quick Start](#eip-712-quick-start) 
3. [üîç Core Functions Reference](#core-functions-reference)
4. [ü™ô ERC20 Token Operations](#erc20-token-operations)
5. [üìä State Queries](#state-queries)
6. [üéØ Complete Integration Workflows](#complete-integration-workflows)
7. [üîÑ Event Monitoring](#event-monitoring)
8. [üñ•Ô∏è User Experience with EIP-712 Signatures](#user-experience-with-eip-712-signatures)
9. [üîê Security Considerations](#security-considerations)
10. [‚ö†Ô∏è Error Handling Reference](#error-handling-reference)
11. [üß™ Testing Utilities](#testing-utilities)
12. [üì± Frontend Integration Examples](#frontend-integration-examples)
13. [üìö Quick Reference](#quick-reference)
14. [üöÄ Relayer Backend for Instant Settlement](#relayer-backend-for-instant-settlement)

---

## üìã Contract Information

### Contract Addresses
```javascript
// Local Development (Hardhat)
const AION_CONTRACT_ADDRESS = "0x5FbDB2315678afecb367f032d93F642f64180aa3";

// Testnet Addresses (Update when deployed)
const AION_TESTNET_ADDRESS = "TBD";

// Mainnet Address (Update when deployed)  
const AION_MAINNET_ADDRESS = "TBD";
```

### Contract ABI Location
```bash
# After compilation, find ABI at:
./artifacts/contracts/AION.sol/AION.json
```

---

## ‚ö° EIP-712 Quick Start

### Why EIP-712?
AION uses **EIP-712 structured data signatures** instead of raw message signing. This means:
- ‚úÖ Users see **clear, readable transaction details** in MetaMask
- ‚úÖ **Better security** - harder to phish users with fake signatures  
- ‚úÖ **Professional UX** - signatures look like legitimate financial transactions
- ‚úÖ **Domain separation** - signatures tied to your specific contract

### Migration from EIP-191
If you're upgrading from raw message signing:

```javascript
// ‚ùå OLD WAY (EIP-191) - Shows cryptic hex
const messageHash = ethers.utils.solidityKeccak256([...]);
const signature = await signer.signMessage(ethers.utils.arrayify(messageHash));

// ‚úÖ NEW WAY (EIP-712) - Shows structured data
const signature = await signer._signTypedData(domain, types, message);
```

### Essential EIP-712 Components

```javascript
// Domain identifies your contract uniquely
const domain = {
    name: "AION",           // Your protocol name
    version: "1",           // Version for upgrades
    chainId: 1,             // Prevent cross-chain replay
    verifyingContract: contractAddress
};

// Types define the data structure
const types = {
    ETHTransfer: [
        { name: "from", type: "address" },
        { name: "to", type: "address" },
        { name: "amount", type: "uint256" },
        { name: "nonce", type: "bytes32" },
        { name: "deadline", type: "uint256" }
    ]
};

// Message contains the actual data
const message = {
    from: "0x742d...",
    to: "0x8ba1...",
    amount: "1500000000000000000",
    nonce: "0xabcd...",
    deadline: 1704123456
};
```

---

## üîç Core Functions Reference

### 1. Lock Funds (ETH)

**Function Signature:**
```solidity
function lockFundsETH() external payable
```

**Parameters:**
- `msg.value`: Amount of ETH to lock (in wei)

**Requirements:**
- `msg.value > 0`

**Events Emitted:**
```solidity
event FundsLockedETH(address indexed user, uint256 amount, uint256 timestamp);
```

**JavaScript Example:**
```javascript
// Lock 1 ETH
const tx = await aionContract.lockFundsETH({
    value: ethers.utils.parseEther("1.0")
});
await tx.wait();
```

**Error Conditions:**
- `"Locking amount must be greater than zero"` - if msg.value is 0

---

### 2. Create Signed Transfer

**Function Signature:**
```solidity
function executeETHTransfer(
    address from,
    address to, 
    uint256 amount,
    bytes32 nonce,
    uint256 deadline,
    bytes memory signature
) external nonReentrant allowTransferDuringGracePeriod(from)
```

**Off-Chain Signature Creation:**

```javascript
/**
 * Creates a signed transfer message using EIP-712
 * @param {string} from - Sender address
 * @param {string} to - Recipient address  
 * @param {string} amount - Amount in ETH (e.g., "1.0")
 * @param {ethers.Signer} signer - Ethers signer object
 * @param {string} contractAddress - AION contract address
 * @param {number} chainId - Chain ID (1 for mainnet, 11155111 for Sepolia)
 * @returns {Object} Signed message object
 */
async function createSignedTransfer(from, to, amount, signer, contractAddress, chainId) {
    // Generate unique nonce
    const nonce = ethers.utils.randomBytes(32);
    
    // Set deadline (5 minutes from now)
    const deadline = Math.floor(Date.now() / 1000) + 300;
    
    // Convert amount to wei
    const amountWei = ethers.utils.parseEther(amount);
    
    // EIP-712 Domain
    const domain = {
        name: "AION",
        version: "1",
        chainId: chainId,
        verifyingContract: contractAddress
    };
    
    // EIP-712 Types
    const types = {
        ETHTransfer: [
            { name: "from", type: "address" },
            { name: "to", type: "address" },
            { name: "amount", type: "uint256" },
            { name: "nonce", type: "bytes32" },
            { name: "deadline", type: "uint256" }
        ]
    };
    
    // Message data
    const message = {
        from: from,
        to: to,
        amount: amountWei,
        nonce: nonce,
        deadline: deadline
    };
    
    // Sign using EIP-712
    const signature = await signer._signTypedData(domain, types, message);
    
    return {
        from: from,
        to: to,
        amount: amount,
        nonce: ethers.utils.hexlify(nonce),
        deadline: deadline,
        signature: signature,
        contractAddress: contractAddress
    };
}
```

**On-Chain Execution:**

```javascript
/**
 * Executes a signed transfer
 * @param {Object} signedMessage - Message from createSignedTransfer()
 * @param {ethers.Contract} contract - AION contract instance
 */
async function executeSignedTransfer(signedMessage, contract) {
    const tx = await contract.executeETHTransfer(
        signedMessage.from,
        signedMessage.to,
        ethers.utils.parseEther(signedMessage.amount),
        signedMessage.nonce,
        signedMessage.deadline,
        signedMessage.signature
    );
    
    return await tx.wait();
}
```

**Events Emitted:**
```solidity
event FundsTransferred(address indexed from, address indexed to, uint256 amount);
```

**Error Conditions:**
- `"AION: SIGNATURE_EXPIRED"` - deadline has passed
- `"Nonce already used"` - nonce was already used
- `"Invalid sender signature"` - signature verification failed
- `"AION: SENDER_WITHDRAWAL_LOCKOUT"` - sender has withdrawal active past grace period

---

### 3. Withdrawal Process

**Step 1: Initiate Withdrawal**
```solidity
function initiateWithdrawal() external noActiveWithdrawal(msg.sender)
```

**JavaScript Example:**
```javascript
const tx = await aionContract.initiateWithdrawal();
await tx.wait();
```

**Step 2: Execute Withdrawal (after delay)**
```solidity
function withdrawFundsETH() external onlyAfterDelay(msg.sender) nonReentrant
```

**JavaScript Example:**
```javascript
// Wait 10 minutes after initiation, then:
const tx = await aionContract.withdrawFundsETH();
await tx.wait();
```

**Constants:**
```solidity
uint256 public constant WITHDRAWAL_DELAY = 10 minutes;
```

---

## ü™ô ERC20 Token Operations

### 1. Lock ERC20 Tokens

**Function Signature:**
```solidity
function lockFundsERC20(address token, uint256 amount) external
```

**Parameters:**
- `token`: ERC20 token contract address
- `amount`: Amount of tokens to lock (in token's smallest unit)

**Requirements:**
- `amount > 0`
- User must have approved the AION contract to spend tokens
- User must have sufficient token balance

**Events Emitted:**
```solidity
event FundsLockedERC20(address indexed user, address indexed token, uint256 amount, uint256 timestamp);
```

**JavaScript Example:**
```javascript
// First approve the AION contract to spend tokens
const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
const approveTx = await tokenContract.approve(aionContractAddress, ethers.utils.parseUnits("10.0", 18));
await approveTx.wait();

// Then lock the tokens
const lockTx = await aionContract.lockFundsERC20(
    tokenAddress,
    ethers.utils.parseUnits("10.0", 18) // 10 tokens with 18 decimals
);
await lockTx.wait();
```

---

### 2. Create Signed ERC20 Transfer

**Function Signature:**
```solidity
function executeERC20Transfer(
    address token,
    address from,
    address to,
    uint256 amount,
    bytes32 nonce,
    uint256 deadline,
    bytes memory signature
) external nonReentrant allowTransferDuringGracePeriodERC20(from, token)
```

**Off-Chain Signature Creation:**

```javascript
/**
 * Creates a signed ERC20 transfer message using EIP-712
 * @param {string} tokenAddress - ERC20 token contract address
 * @param {string} from - Sender address
 * @param {string} to - Recipient address  
 * @param {string} amount - Amount in tokens (e.g., "10.0")
 * @param {number} decimals - Token decimals (e.g., 18 for USDC, 6 for USDT)
 * @param {ethers.Signer} signer - Ethers signer object
 * @param {string} contractAddress - AION contract address
 * @param {number} chainId - Chain ID (1 for mainnet, 11155111 for Sepolia)
 * @returns {Object} Signed message object
 */
async function createSignedERC20Transfer(tokenAddress, from, to, amount, decimals, signer, contractAddress, chainId) {
    // Generate unique nonce
    const nonce = ethers.utils.randomBytes(32);
    
    // Set deadline (5 minutes from now)
    const deadline = Math.floor(Date.now() / 1000) + 300;
    
    // Convert amount to token's smallest unit
    const amountUnits = ethers.utils.parseUnits(amount, decimals);
    
    // EIP-712 Domain
    const domain = {
        name: "AION",
        version: "1",
        chainId: chainId,
        verifyingContract: contractAddress
    };
    
    // EIP-712 Types
    const types = {
        ERC20Transfer: [
            { name: "token", type: "address" },
            { name: "from", type: "address" },
            { name: "to", type: "address" },
            { name: "amount", type: "uint256" },
            { name: "nonce", type: "bytes32" },
            { name: "deadline", type: "uint256" }
        ]
    };
    
    // Message data
    const message = {
        token: tokenAddress,
        from: from,
        to: to,
        amount: amountUnits,
        nonce: nonce,
        deadline: deadline
    };
    
    // Sign using EIP-712
    const signature = await signer._signTypedData(domain, types, message);
    
    return {
        token: tokenAddress,
        from: from,
        to: to,
        amount: amount,
        decimals: decimals,
        nonce: ethers.utils.hexlify(nonce),
        deadline: deadline,
        signature: signature,
        contractAddress: contractAddress
    };
}
```

**On-Chain Execution:**

```javascript
/**
 * Executes a signed ERC20 transfer
 * @param {Object} signedMessage - Message from createSignedERC20Transfer()
 * @param {ethers.Contract} contract - AION contract instance
 */
async function executeSignedERC20Transfer(signedMessage, contract) {
    const amountUnits = ethers.utils.parseUnits(signedMessage.amount, signedMessage.decimals);
    
    const tx = await contract.executeERC20Transfer(
        signedMessage.token,
        signedMessage.from,
        signedMessage.to,
        amountUnits,
        signedMessage.nonce,
        signedMessage.deadline,
        signedMessage.signature
    );
    
    return await tx.wait();
}
```

**Events Emitted:**
```solidity
event FundsTransferredERC20(address indexed from, address indexed to, address indexed token, uint256 amount);
```

---

### 3. ERC20 Withdrawal Process

**Step 1: Initiate ERC20 Withdrawal**
```solidity
function initiateWithdrawalERC20(address token) external noActiveWithdrawalERC20(msg.sender, token)
```

**JavaScript Example:**
```javascript
const tx = await aionContract.initiateWithdrawalERC20(tokenAddress);
await tx.wait();
```

**Step 2: Execute ERC20 Withdrawal (after delay)**
```solidity
function withdrawFundsERC20(address token) external onlyAfterDelayERC20(msg.sender, token) nonReentrant
```

**JavaScript Example:**
```javascript
// Wait 10 minutes after initiation, then:
const tx = await aionContract.withdrawFundsERC20(tokenAddress);
await tx.wait();
```

**Events Emitted:**
```solidity
event WithdrawalInitiatedERC20(address indexed user, address indexed token, uint256 timestamp);
event WithdrawalCancelledERC20(address indexed user, address indexed token, uint256 timestamp);
event FundsWithdrawnERC20(address indexed user, address indexed token, uint256 amount);
```

---

## üìä State Queries

### Check Locked Balance

**ETH Balance:**
```javascript
const balance = await aionContract.lockedFundsETH(userAddress);
const balanceETH = ethers.utils.formatEther(balance);
```

**ERC20 Token Balance:**
```javascript
const tokenBalance = await aionContract.lockedFundsERC20(tokenAddress, userAddress);
const balanceFormatted = ethers.utils.formatUnits(tokenBalance, tokenDecimals);
```

### Check Withdrawal Status

**ETH Withdrawal Status:**
```javascript
const timestamp = await aionContract.withdrawTimestamps(userAddress);
const hasActiveWithdrawal = timestamp.gt(0);

if (hasActiveWithdrawal) {
    const currentTime = Math.floor(Date.now() / 1000);
    const withdrawalTime = timestamp.toNumber();
    const canWithdraw = currentTime >= (withdrawalTime + 600); // 10 minutes
}
```

**ERC20 Withdrawal Status:**
```javascript
const timestamp = await aionContract.withdrawTimestampsERC20(userAddress, tokenAddress);
const hasActiveWithdrawal = timestamp.gt(0);

if (hasActiveWithdrawal) {
    const currentTime = Math.floor(Date.now() / 1000);
    const withdrawalTime = timestamp.toNumber();
    const canWithdraw = currentTime >= (withdrawalTime + 600); // 10 minutes
}
```

### Check Nonce Usage
```javascript
const isUsed = await aionContract.usedNonces(nonceBytes32);
```

### Grace Period Calculation
```javascript
/**
 * Checks if a transfer would be allowed during grace period
 * @param {string} senderAddress - Address of the sender
 * @param {ethers.Contract} contract - AION contract instance
 */
async function isInGracePeriod(senderAddress, contract) {
    const withdrawalTimestamp = await contract.withdrawTimestamps(senderAddress);
    
    if (withdrawalTimestamp.eq(0)) {
        return true; // No active withdrawal
    }
    
    const currentTime = Math.floor(Date.now() / 1000);
    const withdrawalTime = withdrawalTimestamp.toNumber();
    const gracePeriodEnd = withdrawalTime + 300; // 5 minutes
    
    return currentTime <= gracePeriodEnd;
}
```

---

## üéØ Complete Integration Workflows

### Workflow 1: Basic Payment

```javascript
class AIONPaymentHandler {
    constructor(contractAddress, provider) {
        this.contract = new ethers.Contract(contractAddress, AION_ABI, provider);
    }
    
    // Step 1: Sender locks funds
    async lockFunds(amount, signer) {
        const contractWithSigner = this.contract.connect(signer);
        const tx = await contractWithSigner.lockFundsETH({
            value: ethers.utils.parseEther(amount)
        });
        return await tx.wait();
    }
    
    // Step 2: Sender creates payment
    async createPayment(senderAddress, recipientAddress, amount, signer) {
        return await createSignedTransfer(
            senderAddress, 
            recipientAddress, 
            amount, 
            signer, 
            this.contract.address
        );
    }
    
    // Step 3: Recipient (or anyone) executes payment
    async executePayment(signedMessage, executorSigner) {
        const contractWithSigner = this.contract.connect(executorSigner);
        return await executeSignedTransfer(signedMessage, contractWithSigner);
    }
}
```

### Workflow 2: Pre-flight Checks

```javascript
/**
 * Validates a signed message before execution
 * @param {Object} signedMessage - The signed message to validate
 * @param {ethers.Contract} contract - AION contract instance
 */
async function validateSignedMessage(signedMessage, contract) {
    const checks = {
        deadlineValid: false,
        nonceUnused: false,
        senderHasFunds: false,
        inGracePeriod: false,
        signatureValid: false
    };
    
    // Check deadline
    const currentTime = Math.floor(Date.now() / 1000);
    checks.deadlineValid = currentTime <= signedMessage.deadline;
    
    // Check nonce
    checks.nonceUnused = !(await contract.usedNonces(signedMessage.nonce));
    
    // Check sender balance
    const senderBalance = await contract.lockedFundsETH(signedMessage.from);
    const requiredAmount = ethers.utils.parseEther(signedMessage.amount);
    checks.senderHasFunds = senderBalance.gte(requiredAmount);
    
    // Check grace period
    checks.inGracePeriod = await isInGracePeriod(signedMessage.from, contract);
    
    // Note: Signature validation would need to be done on-chain
    checks.signatureValid = true; // Assume valid for pre-flight
    
    return {
        isValid: Object.values(checks).every(Boolean),
        checks: checks
    };
}
```

---

## üîÑ Event Monitoring

### Event Listeners Setup

```javascript
/**
 * Sets up event listeners for AION contract
 * @param {ethers.Contract} contract - AION contract instance
 */
function setupEventListeners(contract) {
    
    // Funds locked
    contract.on("FundsLockedETH", (user, amount, timestamp, event) => {
        console.log(`Funds locked: ${ethers.utils.formatEther(amount)} ETH by ${user}`);
    });
    
    // Transfer executed
    contract.on("FundsTransferred", (from, to, amount, event) => {
        console.log(`Transfer: ${ethers.utils.formatEther(amount)} ETH from ${from} to ${to}`);
    });
    
    // Withdrawal initiated
    contract.on("WithdrawalInitiated", (user, timestamp, event) => {
        console.log(`Withdrawal initiated by ${user} at ${timestamp}`);
    });
    
    // Withdrawal completed
    contract.on("FundsWithdrawn", (user, amount, event) => {
        console.log(`Withdrawal completed: ${ethers.utils.formatEther(amount)} ETH to ${user}`);
    });
}
```

### Query Historical Events

```javascript
/**
 * Gets transfer history for an address
 * @param {ethers.Contract} contract - AION contract instance
 * @param {string} userAddress - Address to query
 * @param {number} fromBlock - Starting block (optional)
 */
async function getTransferHistory(contract, userAddress, fromBlock = 0) {
    const sentFilter = contract.filters.FundsTransferred(userAddress, null);
    const receivedFilter = contract.filters.FundsTransferred(null, userAddress);
    
    const sentEvents = await contract.queryFilter(sentFilter, fromBlock);
    const receivedEvents = await contract.queryFilter(receivedFilter, fromBlock);
    
    return {
        sent: sentEvents.map(event => ({
            to: event.args.to,
            amount: ethers.utils.formatEther(event.args.amount),
            blockNumber: event.blockNumber,
            transactionHash: event.transactionHash
        })),
        received: receivedEvents.map(event => ({
            from: event.args.from,
            amount: ethers.utils.formatEther(event.args.amount),
            blockNumber: event.blockNumber,
            transactionHash: event.transactionHash
        }))
    };
}
```

---

## ‚ö†Ô∏è Error Handling Reference

### Common Error Messages

| Error Message | Cause | Solution |
|--------------|-------|----------|
| `"Locking amount must be greater than zero"` | Tried to lock 0 ETH | Send ETH with transaction |
| `"AION: SIGNATURE_EXPIRED"` | Deadline passed | Create new signature |
| `"Nonce already used"` | Replay attack/duplicate | Generate new nonce |
| `"Invalid sender signature"` | Wrong signature | Verify signature creation |
| `"AION: SENDER_WITHDRAWAL_LOCKOUT"` | Grace period expired | Wait or cancel withdrawal |
| `"No ETH funds to withdraw"` | No locked balance | Lock funds first |
| `"Withdrawal delay not met"` | Tried to withdraw too early | Wait 10 minutes |
| `"Active ETH withdrawal request"` | Multiple withdrawal attempts | Cancel or wait |

### Error Handling Pattern

```javascript
async function safeContractCall(contractFunction, ...args) {
    try {
        const tx = await contractFunction(...args);
        return await tx.wait();
    } catch (error) {
        if (error.reason) {
            console.error("Contract Error:", error.reason);
            throw new Error(`AION Error: ${error.reason}`);
        } else if (error.message.includes("user rejected")) {
            throw new Error("Transaction cancelled by user");
        } else {
            console.error("Unknown Error:", error);
            throw new Error("Transaction failed");
        }
    }
}
```

---

## üß™ Testing Utilities

### Test Helper Functions

```javascript
/**
 * Test utilities for AION integration
 */
class AIONTestUtils {
    constructor(contract, signers) {
        this.contract = contract;
        this.signers = signers;
    }
    
    // Fast-forward time in test environment
    async fastForward(seconds) {
        await ethers.provider.send("evm_increaseTime", [seconds]);
        await ethers.provider.send("evm_mine");
    }
    
    // Get test signed message
    async getTestSignedMessage(fromIndex = 0, toIndex = 1, amount = "1.0") {
        return await createSignedTransfer(
            this.signers[fromIndex].address,
            this.signers[toIndex].address,
            amount,
            this.signers[fromIndex],
            this.contract.address
        );
    }
    
    // Setup test scenario
    async setupBasicScenario() {
        // Signer 0 locks 10 ETH
        await this.contract.connect(this.signers[0]).lockFundsETH({
            value: ethers.utils.parseEther("10.0")
        });
        
        return {
            sender: this.signers[0],
            recipient: this.signers[1],
            executor: this.signers[2]
        };
    }
}
```

---

## üì± Frontend Integration Examples

### React Hook for AION

```javascript
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';

export function useAION(contractAddress, provider) {
    const [contract, setContract] = useState(null);
    const [userBalance, setUserBalance] = useState('0');
    const [account, setAccount] = useState('');
    
    useEffect(() => {
        if (provider && contractAddress) {
            const aionContract = new ethers.Contract(contractAddress, AION_ABI, provider);
            setContract(aionContract);
        }
    }, [provider, contractAddress]);
    
    const refreshBalance = async (address) => {
        if (contract && address) {
            const balance = await contract.lockedFundsETH(address);
            setUserBalance(ethers.utils.formatEther(balance));
        }
    };
    
    const lockFunds = async (amount, signer) => {
        if (!contract) throw new Error("Contract not initialized");
        
        const contractWithSigner = contract.connect(signer);
        const tx = await contractWithSigner.lockFundsETH({
            value: ethers.utils.parseEther(amount)
        });
        
        await tx.wait();
        await refreshBalance(await signer.getAddress());
        return tx;
    };
    
    return {
        contract,
        userBalance,
        lockFunds,
        refreshBalance,
        createSignedTransfer: (from, to, amount, signer) => 
            createSignedTransfer(from, to, amount, signer, contractAddress),
        executeTransfer: (signedMessage, signer) => 
            executeSignedTransfer(signedMessage, contract.connect(signer))
    };
}
```

---

## üñ•Ô∏è User Experience with EIP-712 Signatures

### What Users See in MetaMask

With EIP-712, users get **crystal-clear visibility** into what they're signing instead of cryptic hex strings.

#### **Before (EIP-191) - Confusing & Risky:**
```
üîê Sign Message

Message:
0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef

‚ö†Ô∏è Only sign this message if you trust the site
```
*Users had no idea what they were authorizing!* üò∞

#### **After (EIP-712) - Clear & Professional:**

**ETH Transfer Signature:**
```
üîê Sign Typed Data

Domain:
  Name: AION
  Version: 1
  Chain ID: 1 (Ethereum Mainnet)
  Verifying Contract: 0x1234...5678

Message:
  From: 0x742d...3aE6
  To: 0x8ba1...f00d
  Amount: 1500000000000000000 (1.5 ETH)
  Nonce: 0xabcd...1234
  Deadline: 1704123456 (Jan 1, 2024 12:34 PM)

‚ö†Ô∏è By signing, you authorize this ETH transfer
```

**ERC20 Transfer Signature:**
```
üîê Sign Typed Data

Domain:
  Name: AION
  Version: 1
  Chain ID: 1 (Ethereum Mainnet)
  Verifying Contract: 0x1234...5678

Message:
  Token: 0x6B17...5E12 (USDC Contract)
  From: 0x742d...3aE6
  To: 0x8ba1...f00d
  Amount: 1000000 (1.0 USDC)
  Nonce: 0xabcd...1234
  Deadline: 1704123456 (Jan 1, 2024 12:34 PM)

‚ö†Ô∏è By signing, you authorize this token transfer
```

### üéØ User Experience Benefits

1. **üíé Crystal Clear Intent**: Users see exactly what they're authorizing
2. **üõ°Ô∏è Phishing Protection**: Much harder to trick users with fake signatures
3. **üìã Full Transparency**: Every field is labeled and human-readable
4. **‚è∞ Time Awareness**: Users see exactly when signatures expire
5. **üèõÔ∏è Domain Verification**: Users know it's specifically for YOUR AION contract
6. **üîç Contract Verification**: The exact contract address is displayed
7. **‚ö° Professional Appearance**: Looks like a legitimate financial transaction

### üì± Mobile Wallet Experience

**MetaMask Mobile** and other wallets show the same structured data:
- **Large, readable text** for amounts and addresses
- **Clear section headers** (Domain, Message)
- **Warning messages** that make sense in context
- **Timestamp formatting** in local timezone

### üîß Developer Implementation

To ensure users see this beautiful interface, use the correct EIP-712 signature method:

```javascript
// ‚úÖ CORRECT - EIP-712 Structured Data
const signature = await signer._signTypedData(domain, types, message);

// ‚ùå WRONG - Old method that shows hex
const signature = await signer.signMessage(messageHash);
```

### üé® Customizing the User Experience

You can enhance the UX further by:

1. **Adding contextual information** in your frontend before signature:
```javascript
// Show users what they're about to sign
const confirmationText = `
You're about to authorize a payment of ${amount} ETH 
from your AION balance to ${recipientName}.
This signature expires in 5 minutes.
`;
```

2. **Explaining the process**:
```javascript
const explainerText = `
üîê You're signing a secure payment authorization.
üìù This does NOT send funds immediately.
‚ö° The recipient (or anyone) can execute this payment.
üõ°Ô∏è Your funds stay protected by AION's withdrawal delays.
`;
```

3. **Showing signature status**:
```javascript
// After signing
const statusText = `
‚úÖ Signature created successfully!
üìã Share this signed message with the recipient.
‚è±Ô∏è Valid until: ${new Date(deadline * 1000).toLocaleString()}
`;
```

### üö® Common User Questions & Answers

**Q: "Why am I signing instead of sending directly?"**
A: AION uses signatures for **gasless payments**. The recipient pays gas, but your authorization is required.

**Q: "What happens if I sign this?"**
A: You authorize a specific payment amount. The recipient can execute it, but your funds stay protected by withdrawal delays.

**Q: "Can this signature be used multiple times?"**
A: No, each signature has a unique nonce and can only be used once.

**Q: "What if I change my mind?"**
A: Don't share the signature, or initiate a withdrawal to enter the grace period where transfers are restricted.

**Q: "Is this secure?"**
A: Yes, EIP-712 signatures are industry standard, used by Uniswap, OpenSea, and other major protocols.

### üìä User Trust Metrics

Projects using EIP-712 report:
- **üìà Higher signature completion rates** (fewer abandoned transactions)
- **üìû Fewer support tickets** about "what am I signing?"
- **üõ°Ô∏è Reduced phishing attempts** (users can verify domain/contract)
- **‚≠ê Better user reviews** and trust scores

---

## üîê Security Considerations

### 1. Signature Security
- **Always verify signatures on-chain** - Never trust client-side validation
- **Use unique nonces** - Prevent replay attacks
- **Set reasonable deadlines** - Balance security vs usability (recommended: 5-30 minutes)

### 2. Grace Period Behavior
- **Check withdrawal status** before accepting signed messages
- **Understand the 5-minute grace period** - transfers allowed immediately after withdrawal initiation
- **After grace period** - transfers blocked until withdrawal completes or is cancelled

### 3. Integration Security
- **Validate all inputs** - Especially addresses and amounts
- **Handle edge cases** - Zero amounts, invalid addresses, etc.
- **Monitor events** - Track all contract interactions
- **Test thoroughly** - Use the provided test utilities

---

## üìö Quick Reference

### Essential Constants
```javascript
const WITHDRAWAL_DELAY = 10 * 60; // 10 minutes
const GRACE_PERIOD = 5 * 60;      // 5 minutes  
const DEFAULT_DEADLINE = 5 * 60;  // 5 minutes for signatures
```

### Must-Have Functions
1. `createSignedTransfer()` - Generate payment authorizations *(Uses EIP-712)*
2. `createSignedERC20Transfer()` - Generate ERC20 payment authorizations *(Uses EIP-712)*
3. `executeSignedTransfer()` - Execute payments
4. `executeSignedERC20Transfer()` - Execute ERC20 payments
5. `validateSignedMessage()` - Pre-flight validation
6. `isInGracePeriod()` - Check withdrawal status

### EIP-712 Signature Requirements
- **Always use** `signer._signTypedData()` for structured data
- **Never use** `signer.signMessage()` (shows cryptic hex to users)
- **Include domain** with contract address and chain ID
- **Use proper types** for ETHTransfer and ERC20Transfer

### Key Events to Monitor
- `FundsLockedETH` - New deposits
- `FundsTransferred` - Successful transfers  
- `WithdrawalInitiated` - Withdrawal started
- `FundsWithdrawn` - Withdrawal completed

---

## üöÄ Relayer Backend for Instant Settlement

### Overview

For true **instant settlement**, AION requires a **relayer backend service** that automatically executes signed transactions. Recipients get immediate confirmation instead of manually executing payments.

### üîÑ Relayer Architecture

```
Frontend ‚Üí Creates Signed Message ‚Üí Relayer Backend ‚Üí Executes on Blockchain ‚Üí Instant Confirmation
```

### üì° Relayer API Specification

#### **POST /api/relay**
Submit signed payment for immediate execution.

**Request:**
```javascript
{
  "signedMessage": {
    "from": "0x...",
    "to": "0x...", 
    "amount": "1.0",
    "nonce": "0x...",
    "deadline": 1234567890,
    "signature": "0x..."
  }
}
```

**Response (202 Accepted):**
```javascript
{
  "status": "accepted",
  "message": "Payment accepted for immediate execution", 
  "requestId": "uuid-here",
  "estimatedConfirmation": "10-30 seconds"
}
```

#### **GET /api/status/:requestId**
Check transaction status.

**Response:**
```javascript
{
  "status": "confirmed", // "pending" | "confirmed" | "failed"
  "transactionHash": "0x...",
  "blockNumber": 12345,
  "timestamp": "2024-01-01T00:00:00Z"
}
```

#### **POST /api/validate**
Validate signed message (dry run).

**Response:**
```javascript
{
  "isValid": true,
  "checks": {
    "deadlineValid": true,
    "nonceUnused": true,
    "senderHasFunds": true,
    "inGracePeriod": true,
    "signatureValid": true
  }
}
```

### üîå Real-Time WebSocket Updates

**Connect to:** `ws://relayer-backend.com/`

**Events:**
```javascript
// Payment accepted for execution
{
  "type": "payment_accepted",
  "requestId": "uuid",
  "from": "0x...",
  "to": "0x...",
  "amount": "1.0",
  "timestamp": "2024-01-01T00:00:00Z"
}

// Payment confirmed on-chain
{
  "type": "payment_confirmed", 
  "requestId": "uuid",
  "transactionHash": "0x...",
  "blockNumber": 12345,
  "gasUsed": "21000"
}

// Payment failed
{
  "type": "payment_failed",
  "requestId": "uuid", 
  "error": "Transaction reverted"
}
```

### üíª Frontend Integration with Relayer

#### **React Hook for Instant Payments**

```javascript
import { useState } from 'react';

export function useInstantPayments(relayerUrl = 'https://relayer.aion.com') {
  const [pendingPayments, setPendingPayments] = useState(new Map());
  
  const sendInstantPayment = async (signedMessage) => {
    try {
      // Submit to relayer
      const response = await fetch(`${relayerUrl}/api/relay`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ signedMessage })
      });
      
      const result = await response.json();
      
      if (response.ok) {
        // Track pending payment
        setPendingPayments(prev => new Map(prev).set(result.requestId, {
          status: 'pending',
          signedMessage,
          timestamp: new Date().toISOString()
        }));
        
        return { success: true, requestId: result.requestId };
      } else {
        return { success: false, error: result.error };
      }
    } catch (error) {
      return { success: false, error: error.message };
    }
  };
  
  const checkPaymentStatus = async (requestId) => {
    try {
      const response = await fetch(`${relayerUrl}/api/status/${requestId}`);
      const status = await response.json();
      
      // Update pending payments
      setPendingPayments(prev => {
        const updated = new Map(prev);
        if (updated.has(requestId)) {
          updated.set(requestId, { ...updated.get(requestId), ...status });
        }
        return updated;
      });
      
      return status;
    } catch (error) {
      return { error: error.message };
    }
  };
  
  return {
    sendInstantPayment,
    checkPaymentStatus,
    pendingPayments: Array.from(pendingPayments.values())
  };
}
```

#### **WebSocket Real-Time Updates**

```javascript
export function usePaymentUpdates(relayerUrl = 'wss://relayer.aion.com') {
  const [updates, setUpdates] = useState([]);
  const [connected, setConnected] = useState(false);
  
  useEffect(() => {
    const ws = new WebSocket(relayerUrl);
    
    ws.onopen = () => setConnected(true);
    ws.onclose = () => setConnected(false);
    
    ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      setUpdates(prev => [update, ...prev].slice(0, 100)); // Keep last 100
    };
    
    return () => ws.close();
  }, [relayerUrl]);
  
  return { updates, connected };
}
```

### üèóÔ∏è Complete Payment Flow

#### **1. Sender Creates Payment**
```javascript
// Frontend code
const { sendInstantPayment } = useInstantPayments();

async function createInstantPayment(to, amount) {
  // Create signed message (same as before)
  const signedMessage = await createSignedTransfer(
    senderAddress, to, amount, signer, contractAddress
  );
  
  // Send to relayer for instant execution
  const result = await sendInstantPayment(signedMessage);
  
  if (result.success) {
    alert(`Payment submitted! Request ID: ${result.requestId}`);
    // Recipient gets instant confirmation via WebSocket
  } else {
    alert(`Payment failed: ${result.error}`);
  }
}
```

#### **2. Recipient Gets Instant Notification**
```javascript
// Recipient's frontend
const { updates } = usePaymentUpdates();

useEffect(() => {
  const latestUpdate = updates[0];
  if (latestUpdate?.type === 'payment_accepted' && 
      latestUpdate.to === recipientAddress) {
    
    // Show instant "payment incoming" notification
    showNotification(`Payment incoming: ${latestUpdate.amount} ETH`);
  }
  
  if (latestUpdate?.type === 'payment_confirmed' && 
      latestUpdate.to === recipientAddress) {
    
    // Show confirmed payment
    showNotification(`Payment confirmed! TX: ${latestUpdate.transactionHash}`);
  }
}, [updates]);
```

### üîß Relayer Backend Requirements

#### **Core Components:**
1. **Transaction Executor** - Executes signed messages on-chain
2. **Payment Validator** - Validates messages before execution  
3. **WebSocket Server** - Real-time updates
4. **Rate Limiter** - Prevents spam/abuse
5. **Analytics Service** - Transaction monitoring
6. **Notification System** - Webhooks for external services

#### **Environment Variables:**
```bash
# Relayer configuration
RELAYER_PRIVATE_KEY=0x...        # Relayer's private key
AION_CONTRACT_ADDRESS=0x...      # Deployed AION contract
RPC_URL=https://...              # Blockchain RPC endpoint
NETWORK=sepolia                  # Network name

# API configuration  
PORT=3001                        # Server port
ENABLE_ANALYTICS=true            # Analytics tracking
WEBHOOK_URL=https://...          # Notification webhooks

# Gas settings
GAS_PRICE=20000000000           # 20 gwei
MAX_GAS_LIMIT=500000            # Max gas per transaction
```

#### **Deployment Options:**
```bash
# Docker deployment
docker run -d \
  --name aion-relayer \
  -p 3001:3001 \
  -e RELAYER_PRIVATE_KEY=0x... \
  -e AION_CONTRACT_ADDRESS=0x... \
  aion-relayer:latest

# Cloud deployment (AWS/GCP/Azure)
# - Use environment variables for secrets
# - Auto-scaling for high throughput
# - Load balancer for multiple instances
# - Redis for shared state
```

### üîê Security Considerations

#### **Relayer Security:**
- **Private Key Protection** - Use hardware security modules (HSM)
- **Rate Limiting** - Prevent spam and DoS attacks
- **Input Validation** - Validate all signed messages
- **Gas Management** - Monitor and limit gas usage
- **Monitoring** - Alert on unusual activity

#### **Economic Model:**
```javascript
// Relayer fee structure (optional)
{
  "baseFee": "0.001", // 0.001 ETH base fee
  "gasFee": "dynamic", // Actual gas cost + markup
  "priorityFee": "0.0005" // Fast execution fee
}
```

### üìä Monitoring & Analytics

#### **Key Metrics:**
- Transactions per second (TPS)
- Average execution time
- Success/failure rates
- Gas costs and optimization
- User adoption metrics

#### **Health Checks:**
```javascript
// GET /health
{
  "status": "healthy",
  "network": "sepolia",
  "blockNumber": 12345,
  "relayerBalance": "10.5 ETH",
  "contractAddress": "0x...",
  "uptime": "99.9%"
}
```

### üöÄ Production Deployment Checklist

- [ ] **Relayer Backend** deployed with monitoring
- [ ] **WebSocket server** for real-time updates  
- [ ] **Rate limiting** and DDoS protection
- [ ] **Private key security** (HSM/encrypted storage)
- [ ] **Health checks** and alerting
- [ ] **Analytics** and performance monitoring
- [ ] **Load balancing** for high availability
- [ ] **Database** for transaction history
- [ ] **Webhook notifications** for external services
- [ ] **Documentation** for API integration

---

This specification serves as your complete integration reference. For questions or clarifications, refer to the test suite in `/test/test.js` for working examples of all functionality. 