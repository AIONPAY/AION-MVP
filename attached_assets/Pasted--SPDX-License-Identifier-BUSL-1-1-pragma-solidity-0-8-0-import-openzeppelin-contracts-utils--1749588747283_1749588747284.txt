// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "./NonTransferableERC20.sol";

contract AION is ReentrancyGuard {
    using ECDSA for bytes32;

    address public owner;
    mapping(address => uint256) public lockedFundsETH;
    mapping(address => mapping(address => uint256)) public lockedFundsERC20;
    mapping(address => uint256) public withdrawTimestamps;
    mapping(address => mapping(address => uint256)) public withdrawTimestampsERC20;
    mapping(bytes32 => bool) public usedNonces;
    mapping(address => address) public wrappedTokenFor;

    uint256 public constant WITHDRAWAL_DELAY = 10 minutes;

    event FundsLockedETH(address indexed user, uint256 amount, uint256 timestamp);
    event FundsLockedERC20(address indexed user, address indexed token, uint256 amount, uint256 timestamp);
    event WithdrawalInitiated(address indexed user, uint256 timestamp);
    event WithdrawalInitiatedERC20(address indexed user, address indexed token, uint256 timestamp);
    event WithdrawalCancelled(address indexed user, uint256 timestamp);
    event WithdrawalCancelledERC20(address indexed user, address indexed token, uint256 timestamp);
    event FundsTransferred(address indexed from, address indexed to, uint256 amount);
    event FundsTransferredERC20(address indexed from, address indexed to, address indexed token, uint256 amount);
    event FundsWithdrawn(address indexed user, uint256 amount);
    event FundsWithdrawnERC20(address indexed user, address indexed token, uint256 amount);
    event WrappedTokenCreated(address indexed underlyingToken, address indexed wrappedToken);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not contract owner");
        _;
    }

    modifier onlyAfterDelay(address user) {
        require(block.timestamp >= withdrawTimestamps[user] + WITHDRAWAL_DELAY, "Withdrawal delay not met");
        _;
    }

    modifier onlyAfterDelayERC20(address user, address token) {
        require(block.timestamp >= withdrawTimestampsERC20[user][token] + WITHDRAWAL_DELAY, "Withdrawal delay not met");
        _;
    }

    modifier noActiveWithdrawal(address user) {
        require(withdrawTimestamps[user] == 0, "Active ETH withdrawal request");
        _;
    }

    modifier noActiveWithdrawalERC20(address user, address token) {
        require(withdrawTimestampsERC20[user][token] == 0, "Active ERC20 withdrawal request");
        _;
    }

    modifier allowTransferDuringGracePeriod(address from) {
        uint256 withdrawalInitiationTime = withdrawTimestamps[from];
        if (withdrawalInitiationTime != 0) {
            require(
                block.timestamp <= withdrawalInitiationTime + (WITHDRAWAL_DELAY / 2),
                "AION: SENDER_WITHDRAWAL_LOCKOUT"
            );
        }
        _;
    }

    modifier allowTransferDuringGracePeriodERC20(address from, address token) {
        uint256 withdrawalInitiationTime = withdrawTimestampsERC20[from][token];
        if (withdrawalInitiationTime != 0) {
            require(
                block.timestamp <= withdrawalInitiationTime + (WITHDRAWAL_DELAY / 2),
                "AION: SENDER_WITHDRAWAL_LOCKOUT"
            );
        }
        _;
    }

    function lockFundsETH() public payable {
        require(msg.value > 0, "Locking amount must be greater than zero");
        lockedFundsETH[msg.sender] += msg.value;
        emit FundsLockedETH(msg.sender, msg.value, block.timestamp);
    }

    function lockFundsERC20(address token, uint256 amount) public {
        require(amount > 0, "Locking amount must be greater than zero");
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        lockedFundsERC20[token][msg.sender] += amount;
        emit FundsLockedERC20(msg.sender, token, amount, block.timestamp);
    }

    function lockAndWrapERC20(address token, uint256 amount) public {
        require(amount > 0, "Locking amount must be greater than zero");

        // Transfer the underlying token to this contract
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        lockedFundsERC20[token][msg.sender] += amount;
        emit FundsLockedERC20(msg.sender, token, amount, block.timestamp);

        // Get or create the wrapped token contract
        address wrappedTokenAddress = wrappedTokenFor[token];
        if (wrappedTokenAddress == address(0)) {
            IERC20Metadata metadataToken = IERC20Metadata(token);
            string memory underlyingName = metadataToken.name();
            string memory underlyingSymbol = metadataToken.symbol();
            string memory wrappedName = string(abi.encodePacked("WRPD", underlyingName));
            string memory wrappedSymbol = string(abi.encodePacked("WRPD", underlyingSymbol));

            wrappedTokenAddress = address(new NonTransferableERC20(wrappedName, wrappedSymbol));
            NonTransferableERC20(wrappedTokenAddress).transferOwnership(address(this));
            wrappedTokenFor[token] = wrappedTokenAddress;
            emit WrappedTokenCreated(token, wrappedTokenAddress);
        }

        // Mint the non-transferable wrapped token to the user
        NonTransferableERC20(wrappedTokenAddress).mint(msg.sender, amount);
    }

    function unwrapAndUnlockERC20(address token, uint256 amount) public noActiveWithdrawalERC20(msg.sender, token) {
        require(amount > 0, "Unwrap amount must be greater than zero");
        address wrappedTokenAddress = wrappedTokenFor[token];
        require(wrappedTokenAddress != address(0), "AION: No wrapped token for this asset");
        
        // Burn the user's receipt tokens
        // The user must have approved this contract to spend their wrapped tokens
        NonTransferableERC20(wrappedTokenAddress).burn(msg.sender, amount);

        // Initiate the withdrawal process for the underlying asset
        require(lockedFundsERC20[token][msg.sender] >= amount, "Not enough locked funds");
        withdrawTimestampsERC20[msg.sender][token] = block.timestamp;
        emit WithdrawalInitiatedERC20(msg.sender, token, block.timestamp);
    }

    function initiateWithdrawal() public noActiveWithdrawal(msg.sender) {
        require(lockedFundsETH[msg.sender] > 0, "No ETH funds to withdraw");
        withdrawTimestamps[msg.sender] = block.timestamp;
        emit WithdrawalInitiated(msg.sender, block.timestamp);
    }

    function cancelWithdrawal() public {
        require(withdrawTimestamps[msg.sender] > 0, "No active ETH withdrawal request");
        withdrawTimestamps[msg.sender] = 0;
        emit WithdrawalCancelled(msg.sender, block.timestamp);
    }

    function cancelWithdrawalERC20(address token) public {
        require(withdrawTimestampsERC20[msg.sender][token] > 0, "No active ERC20 withdrawal request");
        withdrawTimestampsERC20[msg.sender][token] = 0;
        emit WithdrawalCancelledERC20(msg.sender, token, block.timestamp);
    }

    function withdrawFundsETH() public onlyAfterDelay(msg.sender) nonReentrant {
        uint256 amount = lockedFundsETH[msg.sender];
        require(amount > 0, "No funds to withdraw");

        lockedFundsETH[msg.sender] = 0;
        withdrawTimestamps[msg.sender] = 0;

        payable(msg.sender).transfer(amount);
        emit FundsWithdrawn(msg.sender, amount);
    }

    function withdrawFundsERC20(address token) public onlyAfterDelayERC20(msg.sender, token) nonReentrant {
        uint256 amount = lockedFundsERC20[token][msg.sender];
        require(amount > 0, "No funds to withdraw");

        lockedFundsERC20[token][msg.sender] = 0;
        withdrawTimestampsERC20[msg.sender][token] = 0;

        IERC20(token).transfer(msg.sender, amount);
        emit FundsWithdrawnERC20(msg.sender, token, amount);
    }

    // ETH transfer using recipient-managed nonce mechanism
    function executeETHTransfer(
        address from,
        address to,
        uint256 amount,
        bytes32 nonce,
        uint256 deadline,
        bytes memory signature
    ) public nonReentrant allowTransferDuringGracePeriod(from) {
        require(block.timestamp <= deadline, "AION: SIGNATURE_EXPIRED");
        require(!usedNonces[nonce], "Nonce already used");

        // Construct the message hash with the nonce and deadline
        bytes32 message = prefixed(
            keccak256(
                abi.encodePacked(from, to, amount, nonce, deadline, address(this))
            )
        );

        // Verify the sender's signature
        address recoveredAddress = message.recover(signature);
        require(recoveredAddress == from, "Invalid sender signature");

        // Mark the nonce as used
        usedNonces[nonce] = true;

        // Perform the transfer
        lockedFundsETH[from] -= amount;
        payable(to).transfer(amount);
        emit FundsTransferred(from, to, amount);
    }

    // ERC20 transfer using recipient-managed nonce mechanism
    function executeERC20Transfer(
        address token,
        address from,
        address to,
        uint256 amount,
        bytes32 nonce,
        uint256 deadline,
        bytes memory signature
    ) public nonReentrant allowTransferDuringGracePeriodERC20(from, token) {
        require(block.timestamp <= deadline, "AION: SIGNATURE_EXPIRED");
        require(!usedNonces[nonce], "Nonce already used");

        // Construct the message hash with the nonce and deadline
        bytes32 message = prefixed(
            keccak256(
                abi.encodePacked(token, from, to, amount, nonce, deadline, address(this))
            )
        );

        // Verify the sender's signature
        address recoveredAddress = message.recover(signature);
        require(recoveredAddress == from, "Invalid sender signature");

        // Mark the nonce as used
        usedNonces[nonce] = true;

        // Perform the transfer
        lockedFundsERC20[token][from] -= amount;
        IERC20(token).transfer(to, amount);
        emit FundsTransferredERC20(from, to, token, amount);
    }

    // Helper function to verify sender's signature
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}
